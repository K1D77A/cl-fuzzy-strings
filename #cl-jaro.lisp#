(defun fuzzy-string-jaro (str1 str2 &key  (threshold 0.7) (number-chars 4) (equality-pred #'char=))
  (- 1.0 (proximity str1 str2 threshold number-chars equality-pred)))

(defun proximity (str1 str2 threshold  number-chars equality-pred) 
  (let* ((lenstr1 (length str1))
	 (lenstr2 (length str2))
	 (search-range (max 0 (1- (/ (max lenstr1 lenstr2) 2))))
	 (matched1 (make-array lenstr1 :element-type 'boolean :initial-element nil))
	 (matched2 (make-array lenstr2 :element-type 'boolean :initial-element nil))
	 (common 0)
	 (half-transposed 0)
	 (k 0)
	 (transposed 0)
	 (common-d 0)
	 (weight 0)
	 (max 0)
	 (pos 0))
    (loop
       :for i :from 0 :upto (1- lenstr1)
       :for start := (max 0 (- i search-range))
       :for end := (min (+ i search-range 1) lenstr2)
       :do (loop
	      :for j :from start :to (1- end)
	      :for str1i := (aref str1 i)
	      :for str2i := (aref str2 j)
	      :do (print str1i)
	      :do (print str2i)
	      :when (or (not (aref matched2 j)) (funcall equality-pred  str1i str2i))
	      :do (progn   (setf (aref matched1 i) t)
			   (setf (aref matched2 j) t)
			   (incf common)
			   (loop-finish))))
    (if (zerop common)
	0)
    (loop
       :for i :from 0 :upto (1- lenstr1)
       :for val := (aref matched1 i)
       :unless (not val)
         :do (loop
		:while (not (aref matched2 k))
		:do (incf k))
       :unless (not val)
         :if (not  (funcall equality-pred  (aref str1 i)(aref str2 k)))
           :do (incf half-transposed)
       :do (incf k))
    (setf transposed (/ half-transposed 2))
    (setf common-d common)
    (setf weight (/ (+ (/ common-d lenstr1)
		       (/ common-d lenstr2)
		       (/ (- common transposed)
			  common-d))
		    3.0))
    (if (<= weight threshold)
	weight)
    (setf max (min number-chars (min (length str1) (length str2))))
    (loop
       :while (and (< pos max) (funcall equality-pred (aref str1 pos)(aref str2 pos)))
       :do (incf pos))
    (if (zerop pos)
	weight
	(* (+ weight 0.1) pos (- 1.0 weight)))))
	
